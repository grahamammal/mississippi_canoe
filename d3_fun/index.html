<!DOCTYPE html>
<meta charset="utf-8">
<style>

/* CSS goes here. */
.state_data { fill: #eeeeee}

.state_boundary { stroke: #ffffff;
                  fill-opacity: 0;
                  stroke-linejoin: round;
                  stroke-width: 1.5px; }

.river { fill-opacity: 0;
         stroke-linejoin: round;}

.mississippi { stroke: #85C9DE;
               stroke-width: 2.5px;}

.tributary { stroke: #B8D6E0;
             stroke-width: 1.3px;}

.canoe_point { fill-opacity: 0.5}

.gradient { fill-opacity: 0.35}

.guide_lines { stroke: #000000;
               stroke-linecap: round}

.place-label { font-size : 12px;}

</style>
<p>
    <select form="display_var" id="display_var" autofocus> 
        <option value="alt">Altitude</option> 
        <option value="speed">Speed</option> 
        <option value="heading" selected>Heading</option> 
        <option value="climb">Climb</option> 
        <option value="accel_x">X Acceleration</option>
        <option value="accel_y">Y Acceleration</option> 
        <option value="accel_z">Z Acceleration</option> 
        <option value="gyro_x">X Gyroscope</option> 
        <option value="gyro_y">Y Gyroscope</option> 
        <option value="gyro_z">Z Gyroscope</option> 
        <option value="air_tmp">Air Temperature</option> 
        <option value="air_gas">Air Gas</option> 
        <option value="air_hmd">Air Humidity</option> 
        <option value="ar_prss">Air Pressure</option> 
        <option value="wtr_tmp">Water Temperature</option> 
    </select> 
</p>
<body>


<script src="//d3js.org/d3.v4.min.js" charset="utf-8"></script>
<script src="//d3js.org/topojson.v2.min.js"></script>
<script src="//d3js.org/d3-scale-chromatic.v0.3.min.js"></script>
<script src="https://d3js.org/d3-queue.v2.min.js"></script>
<script src="https://d3js.org/d3-scale.v3.min.js"></script>
<script src="https://d3js.org/d3-array.v2.min.js"></script>

<script>


/* JavaScript goes here. */
    var width = 450,
        height = 800;

    var grad_top = 75,
        grad_bottom = 725,
        grad_left = 75,
        grad_width = 20;

    var sym_log_transform_vars = ["accel_x", 
                                  "accel_y",
                                  "accel_z",
                                  "gyro_x",
                                  "gyro_y",
                                  "gyro_z",
                                  "air_gas"]


    function index_to_y(index, chunk) {
        return grad_top +((index + 1500*(chunk-1))/(25432 + 1500*4) )*(grad_bottom-grad_top);
    }

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);
    
    var colorScale = d3.scaleSequential(d3.interpolateViridis)
        .domain([0, 360])

    var projection = d3.geoAlbersUsa()
        .scale(2000)
        .translate([width / 4, height / 2]);

    var path = d3.geoPath()
        .projection(projection)
        .pointRadius(function(d) {
            if(typeof d.geometry !== "undefined" && 
               d.geometry.type === "Point") {
                return 3;

            }
            return 4;
        });

    d3.queue()
        .defer(d3.json, "miss_basin_data.json")
        .defer(d3.csv, "small_clean_legs_non_geom.csv")
        .defer(d3.json, "guide_lines.json")
        .await(ready);

    function ready(error, 
                   miss_basin_data, 
                   small_clean_legs_non_geom,
                   guide_lines) {

        var line = d3.line()
            .x(function(d) {return d.x})
            .y(function(d) {return d.y})

        svg.selectAll(".state_data")
            .data(topojson.feature(miss_basin_data, miss_basin_data.objects.state_data).features)
            .enter().append("path")
            .attr("class", "state_data")
            .attr("fill", function (d) {
                return "#dddddd";
            })
            .attr("d", path);

        svg.append("path")
            .datum(topojson.mesh(miss_basin_data, miss_basin_data.objects.state_data, function(a, b) { return a !== b }))
            .attr("d", path)
            .attr("class", "state_boundary");


        svg.selectAll(".river")
            .data(topojson.feature(miss_basin_data, miss_basin_data.objects.miss_basin_rivers_10).features)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("class", function(d){
                var river_name = d.properties.name
                if(river_name === "Mississippi") {
                    return "river " + "mississippi";
                } else {
                    return "river " + "tributary"
                }
            });
           
        svg.append("path")
            .datum(topojson.feature(miss_basin_data, miss_basin_data.objects.city_data))
            .attr("d", path)
            .attr("class", "city");

        svg.selectAll(".canoe_point")
            .data(topojson.feature(miss_basin_data, miss_basin_data.objects.small_clean_legs).features)
            .enter()
            .append("path")
            .attr("class", "canoe_point")
            .attr("d", path)
            .attr("fill", function (d) {
                return colorScale(d.properties.heading);
            });

        svg.selectAll(".gradient")
            .data(small_clean_legs_non_geom)
            .enter()
            .append("rect") 
            .attr("x", grad_left)
            .attr("y", function(d) {
                return index_to_y(parseInt(d.index), parseInt(d.chunk))
            })
            .attr("fill", function(d) {
                return colorScale(d.heading);
            })
            .attr("width", grad_width)
            .attr("height", 10)
            .attr("class", "gradient");

        svg.selectAll(".guide_lines")
            .data(guide_lines)
            .enter()
            .append("path")
            .attr("class", "guide_lines")
            .attr("d", line)

        svg.selectAll(".city-label")
            .data(topojson.feature(miss_basin_data, miss_basin_data.objects.city_data).features)
            .enter()
            .append("text")
            .attr("class", "place-label")
            .attr("transform", function(d) {return "translate(" + projection(d.geometry.coordinates) + ")"; })
            .attr("dy", "-0.5em")
            .attr("dx", "0.5em")
            .text(function(d) { return d.properties.name; });

        d3.select("#display_var").on("input", function() {
            update(this.value, small_clean_legs_non_geom);
        })
    };

    function update(value, data) {
        var median = d3.median(data, function(d) {
            return parseInt(d[value]);
        }) 
        var extent = d3.extent(data, function(d) {
            return parseInt(d[value]);
        })


        if(sym_log_transform_vars.includes(value)) {
            colorScale = d3.scaleSequentialSymlog(d3.interpolateViridis)
        .domain(extent);
        } else {
            colorScale = d3.scaleSequential(d3.interpolateViridis)
        .domain(extent);
        }


        svg.selectAll(".gradient")
            .attr("fill", function(d) {
                data_value = parseInt(d[value]);
                return isNaN(data_value) ? 'grey' : colorScale(data_value);
            })

        svg.selectAll(".canoe_point")
            .attr("fill", function(d) {
                data_value = parseInt(d.properties[value]);
                return isNaN(data_value) ? 'grey' : colorScale(data_value);
            })
    }




</script>